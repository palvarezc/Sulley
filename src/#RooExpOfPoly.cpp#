/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooExpOfPoly.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

//ClassImp(RooExpOfPoly) 

 RooExpOfPoly::RooExpOfPoly(const char *name, const char *title, 
                        RooAbsReal& _m,
                        RooAbsReal& _pT,
                        RooAbsReal& _l1,
                        RooAbsReal& _l2,
                        RooAbsReal& _l3,
                        RooAbsReal& _l4,
                        RooAbsReal& _l5):
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   pT("pT","pT",this,_pT),
   l1("l1","l1",this,_l1),
   l2("l2","l2",this,_l2),
   l3("l3","l3",this,_l3),
   l4("l4","l4",this,_l4),
   l5("l5","l5",this,_l5)
 { 
 } 


 RooExpOfPoly::RooExpOfPoly(const RooExpOfPoly& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   pT("pT",this,other.pT),
   l1("l1",this,other.l1),
   l2("l2",this,other.l2),
   l3("l3",this,other.l3),
   l4("l4",this,other.l4),
   l5("l5",this,other.l5)
 { 
 } 



 Double_t RooExpOfPoly::evaluate() const 
 { 
   if(m<0 || pT<0) return 1e-13;
   double ret(0);
   ret = TMath::Exp( - l1*m - l2*pT - l3*pT*pT - l4*m*pT - l5*m*pT*pT);   // + l6*m*pT*pT*pT );
   return ret; 
 } 


Int_t RooExpOfPoly::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
{
   if(matchArgs(allVars, analVars, m)) return 1;
   if(matchArgs(allVars, analVars, pT)) return 2;
   return 0;
}

Double_t RooExpOfPoly::analyticalIntegral(Int_t code, const char* rangeName) const
{
   switch(code)
   {
      case 1:
         {
            double mMin(m.min(rangeName));
            double mMax(m.max(rangeName));
            double ret(0);

            if(mMin<=0 && mMax<=0) return 0;
            if(mMin< 0) mMin = 0;

            ret += -(TMath::Exp(-l1*mMax - pT*(l2 + l4*mMax + l3*pT + l5*mMax*pT))/(l1 + pT*(l4 + l5*pT)));
            ret -= -(TMath::Exp(-l1*mMin - pT*(l2 + l4*mMin + l3*pT + l5*mMin*pT))/(l1 + pT*(l4 + l5*pT)));


            return ret;
         }
      case 2:
         {
            double pTMin(pT.min(rangeName));
            double pTMax(pT.max(rangeName));
            double ret(0);

            if(pTMin<=0 && pTMax<=0) return 0;
            if(pTMin< 0) pTMin = 0;

            ret += (TMath::Exp(-l1*m - (-l2*l2 - 2*l2*l4*m - l4*l4*m*m)/(4*(l3 + l5*m))) * sqrt(M_PI)*TMath::Erf((l2 + l4*m + 2*l3*pTMax + 2*l5*m*pTMax)/(2*sqrt(l3 + l5*m))))/(2*sqrt(l3 + l5*m)); 
            ret -= (TMath::Exp(-l1*m - (-l2*l2 - 2*l2*l4*m - l4*l4*m*m)/(4*(l3 + l5*m))) * sqrt(M_PI)*TMath::Erf((l2 + l4*m + 2*l3*pTMin + 2*l5*m*pTMin)/(2*sqrt(l3 + l5*m))))/(2*sqrt(l3 + l5*m)); 

            return ret;
         }
   }

   assert(0);
   return 0;
}


