/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooExpBinned.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "TF1.h"


//ClassImp(RooExpBinned) 

 RooExpBinned::RooExpBinned(const char *name, const char *title, 
                        RooAbsReal& _m,
                        RooAbsReal& _l1,
                        RooAbsBinning& _m_binning) :
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   l1("l1","l1",this,_l1),
   m_nbins(_m_binning.numBins()),
   m_lowBound(_m_binning.lowBound()),
   m_highBound(_m_binning.highBound())
 { 
   

   std::string gridname = "grid_";
   gridname+= name;
   grid = new TH1D(gridname.c_str(), gridname.c_str(),m_nbins, m_lowBound, m_highBound);
   

 } 


 RooExpBinned::RooExpBinned(const RooExpBinned& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   l1("l1",this,other.l1),
   m_nbins(other.m_nbins),
   m_lowBound(other.m_lowBound),
   m_highBound(other.m_highBound)
 {

   std::string gridname = "grid_";
   if (name) gridname+= name;
   grid = new TH1D(gridname.c_str(), gridname.c_str(),m_nbins, m_lowBound, m_highBound);   

 }




Double_t RooExpBinned::evaluate() const
{
   if(m<0) return 1e-13;
   double ret(0);

   int bin_number_m = grid->GetXaxis()->FindFixBin(m);
   if (bin_number_m<1 || bin_number_m>grid->GetXaxis()->GetNbins()) return 0;
   double m_min = grid->GetXaxis()->GetBinLowEdge(bin_number_m);
   double m_max = grid->GetXaxis()->GetBinLowEdge(bin_number_m+1);

   ret += -(TMath::Exp(-l1*m_max))/( l1 );      
   ret -= -(TMath::Exp(-l1*m_min))/( l1 );     

   
   double binWidth = (m_max-m_min);
   ret = ret/binWidth;

   return ret;
}



Int_t RooExpBinned::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
{
  if(matchArgs(allVars, analVars, m)) return 1;
  return 0;
}

Double_t RooExpBinned::analyticalIntegral(Int_t code, const char* rangeName) const
{
   switch(code)
   {
      case 1:
         {

           double m_min, m_max;
           
           double sum(0);
           for(int i=1; i<m_nbins+1; i++)
           {
             m_min = grid->GetXaxis()->GetBinLowEdge(i);
             m_max = grid->GetXaxis()->GetBinLowEdge(i+1);
             sum += -(TMath::Exp(-l1*m_max))/( l1 );
             sum -= -(TMath::Exp(-l1*m_min))/( l1 );
               
           }
           

           return sum;
         }

     
   }


   
   assert(0);
   return 0;
}

