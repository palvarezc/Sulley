#define analysis_histfact_working_cxx
#include <iostream>
#include <stdio.h>

#include "TRandom3.h"
#include "TCanvas.h"
#include "TDatime.h"
#include "TStopwatch.h"
#include "TLegend.h"
#include "TIterator.h"
#include "TH3.h"
#include "TLatex.h"
#include "TGaxis.h"

#include "RooChi2Var.h"
#include "RooAbsData.h"
#include "RooRealSumPdf.h"
#include "RooPoisson.h"
#include "RooGaussian.h"
#include "RooRealVar.h"
#include "RooMCStudy.h"
#include "RooMinuit.h"
#include "RooCategory.h"
#include "RooHistPdf.h"
#include "RooSimultaneous.h"
#include "RooExtendPdf.h"
#include "RooDataSet.h"
#include "RooDataHist.h"
#include "RooFitResult.h"
#include "RooMsgService.h"
#include "RooParamHistFunc.h"
#include "RooHist.h"
#include "RooRandom.h"

#include "RooStats/ModelConfig.h"
#include "RooStats/ToyMCSampler.h"
#include "RooStats/MinNLLTestStat.h"

#include "RooStats/HistFactory/FlexibleInterpVar.h"
#include "RooStats/HistFactory/PiecewiseInterpolation.h"
#include "RooStats/HistFactory/HistFactorySimultaneous.h"
#include "RooStats/HistFactory/Channel.h"
#include "RooStats/HistFactory/MakeModelAndMeasurementsFast.h"
#include "RooStats/HistFactory/Measurement.h"
#include "RooStats/HistFactory/ParamHistFunc.h"
#include "RooStats/HistFactory/HistFactoryModelUtils.h"
#include "RooStats/HistFactory/RooBarlowBeestonLL.h"
#include "src/RooMcorMvisTsallis.h"


using namespace std;
using namespace RooFit;
using namespace RooStats ;
using namespace HistFactory ;

TDatime *date = new TDatime();

void analysis_histfact_working()
{

  //Some stylistic things:
  TLatex *t=new TLatex();
  t->SetTextAlign(22);
  t->SetTextSize(0.06);
  t->SetTextFont(132);
  gROOT->ProcessLine("gStyle->SetLabelFont(132,\"xyz\");");
  gROOT->ProcessLine("gStyle->SetTitleFont(132,\"xyz\");");
  gROOT->ProcessLine("gStyle->SetTitleFont(132,\"t\");");
  gROOT->ProcessLine("gStyle->SetTitleSize(0.08,\"t\");");
  gROOT->ProcessLine("gStyle->SetTitleY(0.970);");
  char substr[128];
  //For ToyMC, so I can run multiple copies with different seeds without recompiling
  RooRandom::randomGenerator()->SetSeed(date->Get()%100000);
  cout << date->Get()%100000 << endl; 

  RooMsgService::instance().setGlobalKillBelow(RooFit::WARNING) ; //avoid accidental unblinding!

  //Open the ROOT file with the histograms in and renormalise the fit components to 1.

  TFile q("toyMaker/histograms.root");
  TH2 *htemp;

  TString mchistos[4]={"signal_zero","signal_one","signal_two","partreco"};
  double mcN_sigzero,mcN_sigone,mcN_sigtwo , mcN_partreco;
  double *mcnorms[4]={&mcN_sigzero,&mcN_sigone,&mcN_sigtwo ,& mcN_partreco};
  for(int i =0; i < 4; i++){
    q.GetObject(mchistos[i],htemp);
    assert(htemp!=NULL);
    *(mcnorms[i])=1./htemp->Integral();
    cout << "mcN_"+mchistos[i]+" = " << 1./ *(mcnorms[i]) << endl;
  }

  // // Useful later to have the bin max and min for drawing
  // TH2 *JUNK;
  // q.GetObject("partreco",JUNK);
  // double q2_low=JUNK->GetZaxis()->GetXmin();
  // double q2_high=JUNK->GetZaxis()->GetXmax();
  // const int q2_bins = JUNK->GetZaxis()->GetNbins();
  // JUNK->SetDirectory(0);
  q.Close();

  // Many many flags for steering
  /* STEERING OPTIONS */ 
  const bool constrainDstst=true;
  const bool useMinos=true;
  const bool useMuShapeUncerts = false;
  const bool useTauShapeUncerts = false;
  const bool fixshapes = true;
  const bool dofit = true;
  const bool toyMC = false;
  const bool fitfirst = false;
  const bool slowplots = true;
  const bool BBon3d = false;
  const bool blind = false;
  const int  blindingSeed = 110689 ;
 
  TRandom3 * r3 = new TRandom3(blindingSeed);
 
  // Set the prefix that will appear before
  // all output for this measurement
  RooStats::HistFactory::Measurement meas("my_measurement","my measurement");
  meas.SetOutputFilePrefix("results/my_measurement");
  meas.SetExportOnly(kTRUE);

  meas.SetPOI("Nsig");

  meas.SetLumi(1.0);
  meas.SetLumiRelErr(0.05);

  double Nsig = 560.;
  double Npartreco = 550.;
  double fpartreco = 1;
  
// double fzero = 1.;
  // double fone = 0;
  // double ftwo = 0;
  
  double fzero = 0.368;
  double fone = 0.484;
  double ftwo = 1- fzero - fone;

  //Get the blinding scale
  if(blind) cout<<"Using blinding seed: "<<blindingSeed<<" first random number: "<<r3->Uniform(0.5,1.5)<<endl;
  const double blindScale = (blind)? r3->Uniform(0.5,1.5) : 1. ;

  double RelLumi = 1.00;

  //Now setup the measurement:
  RooStats::HistFactory::Channel chan("RK_kinematic");
  chan.SetStatErrorConfig(1e-5,"Poisson");
  chan.SetData("dataToy", "toyMaker/histograms.root");

  //Setup the zero brem 
  RooStats::HistFactory::Sample sigzero("signal_zero_sample","signal_zero", "toyMaker/histograms.root");
  if(BBon3d) sigzero.ActivateStatError();
  sigzero.SetNormalizeByTheory(kFALSE);
  sigzero.AddNormFactor("Nsig", Nsig, 1e-6, 1e6);
  sigzero.AddNormFactor("blindEff",blindScale,0.5,1.5);
  sigzero.AddNormFactor("fzero", fzero,0.,1.);
  sigzero.AddNormFactor("mcNorm_sigzero", mcN_sigzero, 1e-9, 1.);
  chan.AddSample(sigzero);

  //Setup the one brem
  RooStats::HistFactory::Sample sigone("signal_one_sample","signal_one", "toyMaker/histograms.root");
  if(BBon3d) sigone.ActivateStatError();
  sigone.SetNormalizeByTheory(kFALSE);
  sigone.AddNormFactor("Nsig",Nsig,1e-6,1e6);
  sigone.AddNormFactor("blindEff",blindScale,0.5,1.5);
  sigone.AddNormFactor("fone",fone,0.,1.);
  sigone.AddNormFactor("mcNorm_sigone", mcN_sigone, 1e-9, 1.);
  chan.AddSample(sigone);

  //Setup the one brem
  RooStats::HistFactory::Sample sigtwo("signal_two_sample","signal_two", "toyMaker/histograms.root");
  if(BBon3d) sigtwo.ActivateStatError();
  sigtwo.SetNormalizeByTheory(kFALSE);
  sigtwo.AddNormFactor("Nsig",Nsig,1e-6,1e6);
  sigtwo.AddNormFactor("blindEff",blindScale,0.5,1.5);
  sigtwo.AddNormFactor("ftwo",ftwo,0.,1.);
  sigtwo.AddNormFactor("mcNorm_sigtwo", mcN_sigtwo, 1e-9, 1.);
  chan.AddSample(sigtwo);

  //Setup the lambdac background
  RooStats::HistFactory::Sample partreco("partreco_sample","partreco", "toyMaker/histograms.root");
  if(BBon3d) partreco.ActivateStatError();
  partreco.SetNormalizeByTheory(kFALSE);
  // partreco.AddNormFactor("fpartreco",fpartreco,0.,3.);
  // partreco.AddNormFactor("Nsig",Nsig,0,1e6);
  partreco.AddNormFactor("Npartreco",Npartreco,1e-6,1e6);
  partreco.AddNormFactor("mcNorm_partreco", mcN_partreco, 1e-9, 1.);
  chan.AddSample(partreco);

  meas.AddChannel(chan);
  meas.CollectHistograms();

  //Create the workspace that is going to save the config
  RooWorkspace *w;
  w=RooStats::HistFactory::MakeModelAndMeasurementFast(meas);
  
  ModelConfig *mc = (ModelConfig*) w->obj("ModelConfig"); // Get model manually
  RooSimultaneous *model = (RooSimultaneous*)mc->GetPdf();
  model->Print();
  cout<<"here!"<<endl;
  

  RooRealVar* poi = (RooRealVar*) mc->GetParametersOfInterest()->createIterator()->Next();
  std::cout << "Param of Interest: " << poi->GetName() << std::endl;

  // Lets tell roofit the right names for our histogram variables //
  RooArgSet *obs = (RooArgSet*) mc->GetObservables();
  RooRealVar *x = (RooRealVar*) obs->find("obs_x_RK_kinematic");
  RooRealVar *y = (RooRealVar*) obs->find("obs_y_RK_kinematic");
  x->SetTitle("B_plus_M");
  x->setUnit("MeV/c^{2}");
  y->SetTitle("B_plus_M_corr");
  y->setUnit("MeV/c^{2}");

  RooCategory *idx = (RooCategory*) obs->find("channelCat");
  RooAbsData *data = (RooAbsData*) w->data("obsData");

  //Fix the parameters that normalise the histograms, also the luminosity.
  ((RooRealVar*)(mc->GetNuisanceParameters()->find("fzero")))->setConstant(kTRUE);
  ((RooRealVar*)(mc->GetNuisanceParameters()->find("fone")))->setConstant(kTRUE);
  ((RooRealVar*)(mc->GetNuisanceParameters()->find("ftwo")))->setConstant(kTRUE);
  ((RooRealVar*)(mc->GetNuisanceParameters()->find("mcNorm_sigzero")))->setConstant(kTRUE);
  ((RooRealVar*)(mc->GetNuisanceParameters()->find("mcNorm_sigone")))->setConstant(kTRUE);
  ((RooRealVar*)(mc->GetNuisanceParameters()->find("mcNorm_sigtwo")))->setConstant(kTRUE);
  ((RooRealVar*)(mc->GetNuisanceParameters()->find("mcNorm_partreco")))->setConstant(kTRUE);
  ((RooRealVar*)(mc->GetNuisanceParameters()->find("blindEff")))->setConstant(kTRUE);
  ((RooRealVar*)(mc->GetNuisanceParameters()->find("Lumi")))->setConstant(kTRUE);
  

  HistFactorySimultaneous* model_hf = new HistFactorySimultaneous( *model );
  model_hf->SetTitle("MyModelWithCombinatorial");
  
  w->import(*model_hf);
 
  RooFitResult *toyresult;
  RooAbsReal *nll_hf; 
  RooAbsReal *nll; 

  RooFitResult *result, *result2;

  cerr << "Saving PDF snapshot" << endl;
  RooArgSet *allpars;
  allpars=(RooArgSet*)((RooArgSet*) mc->GetNuisanceParameters())->Clone();
  allpars->add(*poi);
  RooArgSet *constraints;
  constraints = (RooArgSet*) mc->GetConstraintParameters();
  if(constraints != NULL) allpars->add(*constraints);
  w->saveSnapshot("TMCPARS",*allpars,kTRUE);
  RooRealVar poierror("poierror","poierror",0.00001,0.010);
  TIterator *iter = allpars->createIterator();
  RooAbsArg *tempvar;
  RooArgSet *theVars = (RooArgSet*) allpars->Clone();
  theVars->add(poierror);

  // nll = model->createNLL(*data);
  // cout<<"NLL value: "<<nll->getVal()<<endl;


  // RooRealSumPdf* model_pdf = ( RooRealSumPdf*) w->pdf("RK_kinematic_model");
  // cout<<"PDF value: "<<model_pdf->getVal()<<endl;
  // cout<<"PDF integral: "<<model_pdf->createIntegral(RooArgSet(*x,*y))->getVal()<<endl;
  
  // RooGaussian* lumiconstrain = (RooGaussian*) w->pdf("lumiConstraint"); 
  // cout<<"Lumi PDF value: "<<lumiconstrain->getVal()<<endl;
  // cout<<"Lumi integral: "<<lumiconstrain->createIntegral(RooArgSet(*x,*y))->getVal()<<endl;
  

  nll_hf= model_hf->createNLL(*data,Offset(kTRUE));

  RooMinuit* minuit_hf = new RooMinuit(*nll_hf) ;
  RooArgSet *temp = new RooArgSet();
  nll_hf->getParameters(temp)->Print("V");
  cout << "**********************************************************************" << endl;
  minuit_hf->setErrorLevel(0.5);
  //#ifndef UNBLIND
  minuit_hf->setPrintLevel(1);
  //#endif
  std::cout << "Minimizing the Minuit (Migrad)" << std::endl;
  w->saveSnapshot("TMCPARS",*allpars,kTRUE);
  minuit_hf->setStrategy(2);
  minuit_hf->fit("smh");
  RooFitResult *tempResult=minuit_hf->save("TempResult","TempResult");
  
  cout << tempResult->edm() << endl;
  if (useMinos) minuit_hf->minos(RooArgSet(*poi));
  result = minuit_hf->save("Result","Result");
  
  
  
  if(result != NULL)
  {
    printf("Fit ran with status %d\n",result->status());
    
    printf("Stat error on Nsig is %f\n",poi->getError());
    
    printf("EDM at end was %f\n",result->edm());
      
    result->floatParsInit().Print();
      
    cout << "CURRENT PARAMETERS:" << endl;
    //TIterator *paramiter = mc->GetNuisanceParameters()->createIterator();
    TIterator *paramiter = result->floatParsFinal().createIterator();
    RooRealVar *__temp= (RooRealVar *)paramiter->Next();
    int final_par_counter=0;
    while (__temp!=NULL)
    {
      if(!__temp->isConstant())
      {
        //          if(!(TString(__temp->GetName()).EqualTo(poi->GetName())))
        //          {
        cout << final_par_counter << ": "
             << __temp->GetName() << "\t\t\t = "
             << ((RooRealVar*)result->floatParsFinal().find(__temp->GetName()))->getVal()
             << " +/- "
             << ((RooRealVar*)result->floatParsFinal().find(__temp->GetName()))->getError() << endl;
        //          }
      }
      final_par_counter++;
      __temp=(RooRealVar *)paramiter->Next();
    }
    
    
    result->correlationMatrix().Print();
  }
  
  //Now for the plotting
  RooPlot *m_frame = x->frame(Title("M(B)"));
  RooPlot *mcor_frame = y->frame(Title("M_{corr}(B)"));
  
  const int nframes = 2;
  RooPlot *drawframes[nframes] = {m_frame, mcor_frame};
  
  const int ncomps = 10;
  int colors[ncomps]={kRed,kBlue+1,kViolet,kViolet+1,kViolet+2,kGreen,kGreen+1,kOrange+1,kOrange+2,kOrange+3};
  const int ncomps2 = 8;
  TString names[ncomps2+1] = {"Data","Total Fit"
                              ,"B #rightarrow K e e"
                              ,"Part. Reco."
  };
      
      
  RooHist* mresid;// = mm2_frame->pullHist() ;
  RooHist* mcorresid;// = El_frame->pullHist() ;
  
  RooHist *resids[nframes];

  for (int i = 0; i < nframes; i++){
    data->plotOn(drawframes[i],Name("data"),DataError(RooAbsData::Poisson),Cut("channelCat==0"),MarkerSize(0.6),DrawOption("ZP"));
    model->plotOn(drawframes[i],Name("model"), Slice(*idx),ProjWData(*idx,*data),DrawOption("F"),FillColor(kRed),LineWidth(0));
    resids[i]=drawframes[i]->pullHist();
    model->plotOn(drawframes[i],Name("signal"), Slice(*idx),ProjWData(*idx,*data),DrawOption("F"),FillColor(kBlue),Components("*zero*,*one*,*two*"),LineWidth(0));
    model->plotOn(drawframes[i],Name("sigzero_sample"), Slice(*idx),ProjWData(*idx,*data),Components("*zero*"),LineWidth(1),LineColor(kYellow));
    model->plotOn(drawframes[i],Name("sigone_sample"), Slice(*idx),ProjWData(*idx,*data),LineColor(kViolet),Components("*one*"),LineWidth(1));
    model->plotOn(drawframes[i],Name("sigtwo_sample"), Slice(*idx),ProjWData(*idx,*data),LineColor(kGreen),Components("*two*"),LineWidth(1));
    model->plotOn(drawframes[i],Name("partreco_sample"), Slice(*idx),ProjWData(*idx,*data),DrawOption("F"),FillColor(kMagenta),Components("*partreco*"),LineWidth(0));
    
    data->plotOn(drawframes[i],Name("data"),DataError(RooAbsData::Poisson),Cut("channelCat==0"),MarkerSize(0.8),DrawOption("ZP"));
  }
  
  
  mresid=resids[0];
  mcorresid=resids[1];
  
  TCanvas *c1 = new TCanvas("c1","c1",1100,600);
  c1->SetTickx();
  c1->SetTicky();
  TPad * pad1 = new TPad("pad1","pad1",0,0.3,0.33,1.0);
  pad1->SetTickx();
  pad1->SetTicky();
  pad1->SetRightMargin(0.11);
  pad1->SetLeftMargin(0.17);
  pad1->SetTopMargin(0.08);
  pad1->SetBottomMargin(0.13);
  pad1->Draw();
  TPad * pad2 = new TPad("pad2","pad2",0.33,0.3,0.66,1.0);
  pad2->SetTickx();
  pad2->SetTicky();
  pad2->SetRightMargin(0.11);
  pad2->SetLeftMargin(0.17);
  pad2->SetTopMargin(0.08);
  pad2->SetBottomMargin(0.12);
  pad2->Draw();
  TPad * pad3 = new TPad("pad3","pad3",0.66,0.3,0.99,1.0);
  pad3->SetTickx();
  pad3->SetTicky();
  pad3->SetRightMargin(0.11);
  pad3->SetLeftMargin(0.17);
  pad3->SetTopMargin(0.08);
  pad3->SetBottomMargin(0.13);
  pad3->Draw();
  TPad * pad4 = new TPad("pad4","pad4",0,0.,0.33,0.3);
  pad4->SetTickx();
  pad4->SetTicky();
  pad4->SetRightMargin(0.11);
  pad4->SetLeftMargin(0.17);
  pad4->SetTopMargin(0.05);
  pad4->SetBottomMargin(0.13);
  pad4->Draw();
  TPad * pad5 = new TPad("pad5","pad5",0.33,0.,0.66,0.3);
  pad5->SetTickx();
  pad5->SetTicky();
  pad5->SetRightMargin(0.11);
  pad5->SetLeftMargin(0.17);
  pad5->SetTopMargin(0.05);
  pad5->SetBottomMargin(0.13);
  pad5->Draw();
  TPad * pad6 = new TPad("pad6","pad6",0.66,0.,0.99,0.3);
  pad6->SetTickx();
  pad6->SetTicky();
  pad6->SetRightMargin(0.11);
  pad6->SetLeftMargin(0.17);
  pad6->SetTopMargin(0.05);
  pad6->SetBottomMargin(0.13);
  pad6->Draw();

  TLegend * leg = new TLegend(0.57,0.6,0.87,0.91);
  leg->SetLineColor(0);
  leg->SetLineWidth(0);
  leg->SetFillStyle(0);
  leg->AddEntry(m_frame->findObject("data"),"data","LP");
  leg->AddEntry(m_frame->findObject("model"),"ALL","F");
  leg->AddEntry(m_frame->findObject("signal"),"B #rightarrow K e e","F");
  leg->AddEntry(m_frame->findObject("sigzero_sample"),"Zero Brem","l");
  leg->AddEntry(m_frame->findObject("sigone_sample"),"One Brem","l");
  leg->AddEntry(m_frame->findObject("sigtwo_sample"),"Two Brem","l");
  leg->AddEntry(m_frame->findObject("partreco_sample"),"PartReco","F");

  pad1->cd();
  m_frame->SetTitle("");
  m_frame->GetXaxis()->SetLabelSize(0.06);
  m_frame->GetXaxis()->SetTitleSize(0.06);
  m_frame->GetYaxis()->SetLabelSize(0.06);
  m_frame->GetYaxis()->SetTitleSize(0.06);
  m_frame->GetYaxis()->SetTitleOffset(1.3);
  m_frame->GetXaxis()->SetTitleOffset(0.9);
  TGaxis * x1 = (TGaxis*)m_frame->GetXaxis();
  x1->SetMaxDigits(3);
  TString thetitle=m_frame->GetYaxis()->GetTitle();
  thetitle.Replace(0,6,"Candidates");
  m_frame->GetYaxis()->SetTitle(thetitle);
  m_frame->Draw();
  leg->Draw();
  t->DrawLatex(2.9,m_frame->GetMaximum()*0.91,"LHCb Internal");
  pad2->cd();
  mcor_frame->SetTitle("");
  mcor_frame->GetXaxis()->SetLabelSize(0.06);
  mcor_frame->GetXaxis()->SetTitleSize(0.06);
  mcor_frame->GetYaxis()->SetLabelSize(0.06);
  mcor_frame->GetYaxis()->SetTitleSize(0.06);
  mcor_frame->GetYaxis()->SetTitleOffset(1.3);
  mcor_frame->GetXaxis()->SetTitleOffset(0.9);
  thetitle=mcor_frame->GetYaxis()->GetTitle();
  thetitle.Replace(0,6,"Candidates");
  mcor_frame->GetYaxis()->SetTitle(thetitle);
  mcor_frame->Draw();
  t->DrawLatex(1800,mcor_frame->GetMaximum()*0.91,"LHCb Internal");

  RooPlot *m_resid_frame=x->frame(Title("M(B)"));
  RooPlot *mcor_resid_frame=y->frame(Title("M_{corr}(B)"));


  m_resid_frame->addPlotable(mresid,"B");
  mcor_resid_frame->addPlotable(mcorresid,"B");


  pad4->cd();
  m_resid_frame->SetTitle("");
  m_resid_frame->GetXaxis()->SetTitle("");
  m_resid_frame->GetXaxis()->SetLabelOffset(0.03);
  m_resid_frame->GetYaxis()->SetTitle("Pull");
  m_resid_frame->GetYaxis()->SetRangeUser(-3,3);
  m_resid_frame->GetYaxis()->SetLabelSize(0.12);
  m_resid_frame->GetYaxis()->SetTitleSize(0.12);
  m_resid_frame->GetYaxis()->SetTitleOffset(0.5);
  m_resid_frame->GetXaxis()->SetLabelSize(0.12);
  mresid->SetLineWidth(0);
  m_resid_frame->Draw();
  pad5->cd();
  mcor_resid_frame->SetTitle("");
  mcor_resid_frame->GetXaxis()->SetLabelOffset(0.03);
  mcor_resid_frame->GetXaxis()->SetTitle("");
  mcor_resid_frame->GetYaxis()->SetTitle("Pull");
  mcor_resid_frame->GetYaxis()->SetRangeUser(-3,3);
  mcor_resid_frame->GetYaxis()->SetLabelSize(0.12);
  mcor_resid_frame->GetYaxis()->SetTitleSize(0.12);
  mcor_resid_frame->GetYaxis()->SetTitleOffset(0.5);
  mcor_resid_frame->GetXaxis()->SetLabelSize(0.12);
  mcorresid->SetLineWidth(0);
  mcor_resid_frame->Draw();


  w->writeToFile("toyMaker/myWorkspace.root");

  cout<<"end"<<endl;

    }
